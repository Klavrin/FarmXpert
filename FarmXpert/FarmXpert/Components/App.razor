<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <base href="/"/>
    <link rel="stylesheet" href="@Assets["lib/bootstrap/dist/css/bootstrap.min.css"]"/>
    <link rel="stylesheet" href="@Assets["app.css"]"/>
    <link rel="stylesheet" href="@Assets["FarmXpert.styles.css"]"/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw/dist/leaflet.draw.css" />
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" rel="stylesheet" />
    <link href="@Assets["_content/MudBlazor/MudBlazor.min.css"]" rel="stylesheet" />

    <ImportMap/>
    <link rel="icon" type="image/png" href="favicon.png"/>
    <HeadOutlet/>
</head>

<body>
<Routes/>

<script src="_framework/blazor.web.js"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw/dist/leaflet.draw.js"></script>
<script src="@Assets["_content/MudBlazor/MudBlazor.min.js"]"></script>
<script>
    window.downloadFile = function (fileName, contentType, content) {
        // Create a blob from the base64 content
        const link = document.createElement('a');
        link.download = fileName;
        link.href = "data:" + contentType + ";base64," + content;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };
</script>
<script>
    window.downloadFileAnotherFile = function (fileName, contentType, content) {
        const link = document.createElement('a');
        link.download = fileName;
        link.href = "data:" + contentType + ";base64," + content;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };
</script>

<script>
  window.leafletMap = {
    map: null,
    drawnItems: null,

    init: function (mapId, lat, lng, zoom, dotnetHelper) {
      this.map = L.map(mapId).setView([lat, lng], zoom);

      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(this.map);

      // layer that holds all drawn shapes
      this.drawnItems = new L.FeatureGroup();
      this.map.addLayer(this.drawnItems);

      // draw toolbar config
      const drawControl = new L.Control.Draw({
        position: 'topright',
        draw: {
          polygon: true,
          rectangle: true,
          marker: true,
          circle: false,
          polyline: false
        },
        edit: {
          featureGroup: this.drawnItems
        }
      });

      this.map.addControl(drawControl);

      // on draw complete
      this.map.on(L.Draw.Event.CREATED, e => {
        const layer = e.layer;
        this.drawnItems.addLayer(layer);

        const geoJson = layer.toGeoJSON();
        dotnetHelper.invokeMethodAsync(
          "ReceiveLandGeoJson",
          JSON.stringify(geoJson)
        );
      });

      // on edit
      this.map.on('draw:edited', e => {
        const layers = e.layers;
        const allGeo = [];

        layers.eachLayer(layer => {
          allGeo.push(layer.toGeoJSON());
        });

        dotnetHelper.invokeMethodAsync(
          "ReceiveEditedLand",
          JSON.stringify(allGeo)
        );
      });

      // on delete
      this.map.on('draw:deleted', e => {
        dotnetHelper.invokeMethodAsync("LandDeleted");
      });
    },

    locateUser: function () {
      this.map.locate({ setView: true, maxZoom: 17 });

      this.map.on('locationfound', e => {
        L.marker(e.latlng).addTo(this.map);
      });
    }
  };
</script>

</body>
</html>